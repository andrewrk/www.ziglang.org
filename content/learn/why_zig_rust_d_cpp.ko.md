---
title: "왜 Zig를 써야하지? 이미 C++, D 그리고 Rust가 있는데?"
mobile_menu_title: "왜 Zig를..."
toc: true
---


## 숨겨진 제어 흐름 없음

Zig 코드가 멀리 점프해서 함수를 호출하려는걸로 보이지 않다면, 실제로 그런겁니다. 이는 다음의 코드가 그저 `foo()`를 호출한 뒤 `bar()`를 호출하는 것을 확신해도 된다는 것이며, 어떤 것의 타입도 알 필요가 없음을 보장합니다:

```zig
var a = b + c.d;
foo();
bar();
```

숨겨진 제어 흐름의 예:

* D에는 필드에 대한 접근처럼 보이지만 실제는 메소드인 `@property` 함수가 있어, 위 예제에서는 `c.d`가 함수를 호출할 수도 있습니다.
* C++, D, Rust에는 연산자 오버로딩이 가능하여, `+` 연산자가 함수를 호출할 수도 있습니다.
* C++, D, Go에는 throw/catch 예외가 있어, `foo()` 함수가 예외를 발생시키고 `bar()` 함수가 불리는 것을 막을 수도 있습니다. (물론, Zig에서도 `foo()` 함수에 deadlock이 발생해 `bar()`가 불리는 것을 막을 수 있지만, 이는 어떠한 튜링-완전 언어에서도 발생할 수 있습니다.)

이러한 디자인 결정은 가독성을 높이기 위함입니다.

## 숨겨진 메모리 할당 없음

Zig는 힙 할당에 있어 간단한 접근 방식을 갖고있습니다. `new` 키워드나
다른 언어에서 사용하는 힙 할당 기능(예: 스트링 연결 연산자[1])이 없습니다.
힙에 대한 전체 개념은 언어가 아닌 라이브러리와 애플리케이션 코드에 의해 관리됩니다.

숨겨진 메모리 할당의 예:

* Go의 `defer`는 함수 로컬 스택에 메모리를 할당합니다. 이 제어 흐름은 비직관적인 작동 방식 외에도
  `defer`를 루프 내부에서 사용할 경우 메모리 부족 오류를
  발생시킬 수 있습니다.
* C++ 코루틴은 호출을 위해 힙 메모리를 할당합니다.
* Go에서는 goroutine이 호출 스택이 깊어질 경우 크기가 재조정 되는 작은 스택들을
  할당하므로, 함수 호출 중에 힙 할당이 발생할 수 있습니다.
* Rust의 주요 표준 라이브러리 API는 메모리 부족 오류 발생 시 패닉을 일으키고,
  할당자 매개변수를 지원하는 대체 API는 사후 고려 사항입니다
  ([rust-lang/rust#29802](https://github.com/rust-lang/rust/issues/29802)를 보세요).

대부분의 가비지 컬렉션 지원 언어는 가비지 컬렉터가 몰래 메모리를 정리하기 때문에
곳곳에서 숨겨진 할당이 일어납니다.

숨겨진 할당의 주된 문제는 코드의 *재사용성*을 떨어뜨린다는 것이며,
배포할 수 있는 환경의 수가 필요 이상으로 제약된다는 것입니다.
간단히 보자면, 메모리 할당의 부작용이 없는 제어 흐름과 함수 호출에
의존해야만 하는 사용 케이스가 존재하며,
그렇기 때문에 프로그래밍 언어는 실제로 이를 보장할 수 있을 때에만
해당 사용 케이스에 이용할 수 있습니다.

Zig에는 힙 할당 기능을 제공하는 표준 라이브러리가 있지만,
부가적인 표준 라이브러리 기능일 뿐이지 언어 자체에 포함되어 있는 것은 아닙니다.
힙 할당자를 아예 쓰지 않는다면, 여러분의 프로그램이 힙 할당을 하지 않는다는 것을 확신할 수 있습니다.

힙 메모리를 할당해야 하는 모든 표준 라이브러리는 `Allocator` 파라미터를 필요로 합니다.
이는 Zig가 독립형 타겟을 지원한다는 것을 의미합니다.
예를 들어 `std.ArrayList`와 `std.AutoHashMap`은 베어메탈 프로그래밍에 사용될 수 있습니다!

커스텀 할당자는 수동 메모리 관리를 쉽게 해줍니다. Zig에는 디버그 할당자가 있어
해제 후 사용이나 이중 해제로부터 안전하게 해줍니다. 이는 자동으로
메모리 누수의 스택 트레이스를 감지하고 출력합니다. 각각의 할당을 독립적으로 관리하는게 아니라
한방에 해제할 수 있도록 한 곳에 모아둘 수 있는 아레나 할당자도 있습니다.
애플리케이션의 요구사항에 따라 퍼포먼스와 메모리 사용량을 개선할 수 있는
특수 목적의 할당자를 사용할 수 있습니다.

[1]: 실제로는 스트링 연결 연산자가 있지만(일반적으로 배열 연결 연산자), 컴파일 타임에만 동작하므로 런타임 힙 할당은 여전히 없습니다.

## 표준 라이브러리 없는 빌드를 기본 지원

위에서 암시한 대로, Zig의 표준 라이브러리는 완전히 선택적입니다. 각 std lib API는 사용할 때에만
프로그램에 컴파일됩니다. Zig는 libc에 link 하거나 안하거나 모두 지원합니다.
Zig는 베어메탈 및 고성능 개발에 적합합니다.

이는 양쪽에서 최고입니다. 예를 들어, WebAssembly 프로그램은
표준 라이브러리의 기능을 사용하면서도 WebAssembly로의 컴파일을 지원하는 다른 프로그래밍 언어에 비해
작은 바이너리 크기를 가집니다.

## 라이브러리를 위한 이식 가능한 언어

프로그래밍의 큰 목표 중 하나는 재사용입니다. 슬프게도, 실제로 우리는 바퀴를 여러 번 다시 발명하고 있습니다. 종종 이는 정당화 되기도 합니다.

 * 애플리케이션에 실시간이 요구된다면, 가비지 컬렉션이나 다른 어떠한 비결정적 동작을 하는 라이브러리는 의존성에 포함될 자격이 없습니다.
 * 언어에서 오류를 무시하기가 너무 쉬우면, 라이브러리가 오류를 올바르게 처리하고 올려보내고 있는지 검증하기 위해 그 라이브러리를 무시하고 새로 구현하여 관련 오류가 올바로 처리 됐음을 알고자 하는 유혹이 있을 수 있습니다. 개발자가 할 수 있는 가장 게으른 일이 오류를 올바르게 처리하는 것이므로, Zig는 라이브러리가 오류를 올바로 표시할 수 있을 것이라는 합리적인 확신을 할 수 있도록 디자인 되었습니다.
 * 현재 실용적으로는 C가 가장 다용도이며 이식 가능한 언어임을 부정할 수 없습니다. C 코드와의 상호작용이 불가능한 언어는 모호해질 위험이 있습니다. Zig는 외부 함수에 대한 C ABI를 간단하게 준수하는 동시에 구현 내에서 일반적인 버그를 방지하는 안전성 및 언어 설계를 도입하여 라이브러리를 위한 새로운 이식 가능한 언어가 되고자 합니다.

## 기존 프로젝트를 위한 패키지 매니저이자 빌드 시스템

Zig는 프로그래밍 언어지만 전통적인 C/C++ 프로젝트에서도 유용하게 쓰일 빌드 시스템과 패키지 매니저도 포함하고 있습니다.

C나 C++ 코드 대신 Zig로 코딩할 수 있을 뿐 아니라, autotools, cmake, make, scons, ninja 및 기타 등등의 툴을 대신해서 사용할 수 있습니다. 또 여기에 기반해 네이티브 의존성을 위한 패키지 매니저도 제공 (예정) 합니다. 이 빌드 시스템은 프로젝트의 전체 코드 기반이 C나 C++일지라도 적절히 동작하도록 되어 있습니다.

apt-get, pacman, homebrew 등의 시스템 패키지 매니저는 최종 사용자 경험을 위한 도구이지만 개발자의 요구사항은 충족하지 못할 수 있습니다. 언어 전용 패키지 매니저는 기여자가 하나도 없는 것과 수십 명 있는 것만큼 차이가 있을 수 있습니다. 오픈소스 프로젝트의 경우 프로젝트를 빌드하는 어려움 그 자체가 잠재적인 기여자들의 큰 장애물이 될 수 있습니다. C/C++ 프로젝트는 의존성이 있을 경우, 특히 패키지 매니저가 없는 Windows 환경인 경우 치명적일 수 있습니다. Zig 자체를 빌드할 때에 조차 대부분의 잠재적인 기여자들은 LLVM 의존성 때문에 어려움을 겪습니다. Zig는 프로젝트가 네이티브 라이브러리를 직접 의존하도록 하는 기능을 제공 (예정) 합니다 - 사용자의 시스템 패키지 매니저가 사용 가능한 적절한 버전을 찾아주는 데에 의존하지 않고, 무슨 시스템을 쓰고 있으며 무슨 플랫폼을 타겟으로 하는지와 상관 없이 한방에 빌드할 수 있는 실질적으로 보장되는 방법으로 말이죠.

Zig는 선언적 API를 사용하는 합리적인 언어를 이용해 프로젝트의 빌드 시스템을 교체할 수 있게 해주며, 패키지 관리 기능도 제공하고, 그에 따라 실제로 다른 C 라이브러리에 의존할 수 있는 기능을 제공합니다. 의존성을 가질 수 있는 능력은 고차원의 추상화와 재사용 가능한 고수준 코드의 증식을 가능케 해줍니다.

## 간결성

C++, Rust, D에는 수많은 기능이 있으며 이는 작업 중인 애플리케이션의 실제 의미를 흐릴 수 있습니다. 어떤 사람들은 애플리케이션 자체를 디버깅하는 대신에 해당 프로그래밍 언어에 대한 자신의 지식을 디버깅하는 모습을 발견하곤 합니다.

Zig에는 매크로가 없으며 메타프로그래밍도 없지만, 복잡한 프로그램도 간결하고 반복적이지 않은 방법으로 표현할 수 있을만큼 충분히 강력합니다. 매크로 기능을 갖고 있는 Rust조차 `format!`은 예외적으로 컴파일러 자체에 구현되어 있습니다. 반면 Zig는 동등한 함수도 컴파일러에 표준 라이브러리로 예외 없이 구현되어 있습니다.

## 도구

Zig는 [다운로드 섹션](/download/)에서 다운로드 받을 수 있습니다. Zig는 Linux, Windows, macOS 및 FreeBSD 용 바이너리를 제공합니다. 이 압축파일로 다음을 얻을 수 있습니다:

* 압축파일 하나를 다운로드하고 해제하면 설치 완료, 시스템 설정 불필요
* 정적으로 컴파일 되어 런타임 의존성 없음
* 성숙되고 잘 지원되는 LLVM 인프라를 이용해 심층 최적화 가능하며 대부분의 주요 플랫폼을 지원
* 별다른 설정 없이 대부분의 주요 플랫폼으로의 크로스 컴파일 가능
* 지원되는 플랫폼에서 동적 컴파일이 필요한 경우를 위해 libc를 위한 소스코드 포함
* 캐시를 지원하는 빌드 시스템 포함
* libc 지원 포함 C 및 C++ 코드 컴파일
